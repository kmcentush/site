{
  
    
        "post0": {
            "title": "FastAPI Authentication with Google OAuth - Part 1",
            "content": "Background . Coming soon. . Google OAuth Credentials . Coming soon. . FastAPI . Imports . At the top of our Python file, we have our imports. . from typing import Optional from fastapi import FastAPI, Depends, HTTPException from fastapi.openapi.docs import get_swagger_ui_html from fastapi.openapi.utils import get_openapi from starlette.config import Config from starlette.requests import Request from starlette.middleware.sessions import SessionMiddleware from starlette.responses import HTMLResponse, JSONResponse, RedirectResponse from authlib.integrations.starlette_client import OAuth . The first Optional and FastAPI imports are standard among FastAPI applications. I want to explicitly call out Depends and HTTPException, which will be used to validate a user&#39;s login credentials prior to an API call. . The Starlette and AuthLib imports are the key to our Google OAuth implementation. They&#39;ll handle all of the heavy lifting, specifically the redirect URI generation and callback handling. Props to their developers as they make our implementation a breeze! . FastAPI Setup . Here we initialize our FastAPI instance with a root homepage. I&#39;ve disabled the default generated documentation because I plan to protect it behind our new user authentication layer later. If the user is not logged in, the pay will display a login link. If the user is logged in, the page will display their email address as well as links to the documentation and logout. . app = FastAPI(docs_url=None, redoc_url=None) app.add_middleware(SessionMiddleware, secret_key=&#39;!secret&#39;) @app.get(&#39;/&#39;) async def home(request: Request): user = request.session.get(&#39;user&#39;) if user is not None: email = user[&#39;email&#39;] html = ( f&#39;&lt;pre&gt;Email: {email}&lt;/pre&gt;&lt;br&gt;&#39; &#39;&lt;a href=&quot;/docs&quot;&gt;documentation&lt;/a&gt;&lt;br&gt;&#39; &#39;&lt;a href=&quot;/logout&quot;&gt;logout&lt;/a&gt;&#39; ) return HTMLResponse(html) return HTMLResponse(&#39;&lt;a href=&quot;/login&quot;&gt;login&lt;/a&gt;&#39;) . Rather than saving our authentication to a cookie manually, I&#39;ve opted to use Starlettes&#39;s SessionMiddleware. I specified a secret key that will be used to encode/decode the cookie. In actual applications, I highly recommended using a more secure key and saving it to an environment/config file. Hardcoding secrets, keys, database credentials, etc. in your files is both bad practice and a security risk. . FastAPI has good documentation on middleware, and the key thing to note is that it can perform operations on requests prior to being passed through to the rest of the application as well before delivering responses. Starlette&#39;s SessionMiddleware documentation explains how it utilizes this technique to add a signed cookie to the user session that is readable but not modifiable. Still confused about what middleware is? Check out the diagram below. . Image source: link . Google OAuth Implementation . With AuthLib, it doesn&#39;t take much work to implement Google OAuth into our FastAPI application. After loading our client ID and client secret from our configuration file, we register it with the following scopes: . openid: required by Google&#39;s OpenID Connect API | email: grants the application access to the user&#39;s email address | profile: grants the applicattion acess to the user&#39;s profile, such as name and profile picture link | . For more information on the allowed scopes, please check out Google&#39;s documentation. . # Initialize our OAuth instance from the client ID and client secret specified in our .env file config = Config(&#39;.env&#39;) oauth = OAuth(config) CONF_URL = &#39;https://accounts.google.com/.well-known/openid-configuration&#39; oauth.register( name=&#39;google&#39;, server_metadata_url=CONF_URL, client_kwargs={ &#39;scope&#39;: &#39;openid email profile&#39; } ) @app.get(&#39;/login&#39;, tags=[&#39;authentication&#39;]) # Tag it as &quot;authentication&quot; for our docs async def login(request: Request): # Redirect Google OAuth back to our application redirect_uri = request.url_for(&#39;auth&#39;) return await oauth.google.authorize_redirect(request, redirect_uri) @app.route(&#39;/auth&#39;) async def auth(request: Request): # Perform Google OAuth token = await oauth.google.authorize_access_token(request) user = await oauth.google.parse_id_token(request, token) # Save the user request.session[&#39;user&#39;] = dict(user) return RedirectResponse(url=&#39;/&#39;) @app.get(&#39;/logout&#39;, tags=[&#39;authentication&#39;]) # Tag it as &quot;authentication&quot; for our docs async def logout(request: Request): # Remove the user request.session.pop(&#39;user&#39;, None) return RedirectResponse(url=&#39;/&#39;) . With our OAuth registered, we next define three endpoints: login, auth, and logout. They do exactly what their names suggest. login redirects to Google&#39;s sign-in page and then back to our FastAPI application once the user is logged in. Next, auth handles this incoming user access token and saves the user to a cookie thanks to our SessionMiddleware from earlier. Lastly, logout clears the user cookie from the session and resets our application back to the start. . At this point, we have functioning Google OAuth in our FastAPI application! By starting up our FastAPI application and heading to http://localhost:8000/ (this is the default url from the uvicorn library; see their documentation), we should see the following: . Clicking the &quot;login&quot; link will take us to the Google OAuth sigin-in page. . After signing in, we&#39;ll be redirected back to our application. Notice that the home page now shows the link to the documentation as well as the the logout link. If you click the logout link, you&#39;ll be redirected back to where we started. If you click the documentation link, you&#39;ll get a dead link. . That&#39;s because after disabled FastAPI&#39;s autogenerated documenation, we never implemented it in our application! Let&#39;s fix that, protecting it with an authentication layer while we&#39;re at it. . Protected Docs . To implement our documentation, we&#39;ll copy the structure of the autogenerated FastAPI documenation while making use of the Depends class. Thanks to FastAPI, we can write a single function that will check for an authenticated user before displaying the documentation. If no user is logged in, it will throw an HTTP 403 error. For more information on FastAPI dependencies, check out the documentation. . # Try to get the logged in user async def get_user(request: Request) -&gt; Optional[dict]: user = request.session.get(&#39;user&#39;) if user is not None: return user else: raise HTTPException(status_code=403, detail=&#39;Could not validate credentials.&#39;) return None @app.route(&#39;/openapi.json&#39;) async def get_open_api_endpoint(request: Request, user: Optional[dict] = Depends(get_user)): # This dependency protects our endpoint! response = JSONResponse(get_openapi(title=&#39;FastAPI&#39;, version=1, routes=app.routes)) return response @app.get(&#39;/docs&#39;, tags=[&#39;documentation&#39;]) # Tag it as &quot;documentation&quot; for our docs async def get_documentation(request: Request, user: Optional[dict] = Depends(get_user)): # This dependency protects our endpoint! response = get_swagger_ui_html(openapi_url=&#39;/openapi.json&#39;, title=&#39;Documentation&#39;) return response . Check this out: If restart our API and navigate to the documentation page again (note: you may need to log in again if your cookie expired), you&#39;ll see this awesome documentation page generated by FastAPI! . To illustrate that it&#39;s protected, go back to the homepage and logout. Then, manually type in the documentation URL. You should get the HTTP 403 error that we defined! . And that&#39;s it! We successfuly created a FastAPI application with an Google OAuth authentication layer wrapped on top of it! . Credits . This tutorial is based on work originally written by Nils de Bruin on Medium. The AuthLib Google OAuth code is adapted from their blog post. .",
            "url": "https://www.slatebit.com/fastapi/google/oauth/2020/08/16/fastapi_google_oauth_part1.html",
            "relUrl": "/fastapi/google/oauth/2020/08/16/fastapi_google_oauth_part1.html",
            "date": " • Aug 16, 2020"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "This is where you put the contents of your About page. Like all your pages, it’s in Markdown format. . This website is powered by fastpages 1. . a blogging platform that natively supports Jupyter notebooks in addition to other formats. &#8617; . |",
          "url": "https://www.slatebit.com/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page10": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://www.slatebit.com/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}